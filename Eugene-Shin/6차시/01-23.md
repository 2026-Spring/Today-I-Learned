# 6차시(1/23) - 각 계층 어노테이션 2

### controller
- RestController 어노테이션
- RequestedMapping 어노테이션
	- 해당 컨트롤러로 들어오는 요청을 어디로 매핑할지 지정
	- `@RequestMapping("/user")`
		- 뒤에 어떤 엔드포인트가 추가로 붙던지 일단 /user 붙어 있으면 해당 컨트롤러로 매핑됨
		- 엔드포인트는 종단간 연결 위해 사용
			- 스페이스바, 언더바, 대문자 지양
			- 하이픈을 대신 사용
- controller 단에서 service 호출해 사용
	- `private final` 변수로 service 객체 받음
		- 초기화 위해 RequiredArgsConstructor 사용
- 하나의 transaction을 하나의 public 메소드로 묶어 줌
	- service단의 Transactional 어노테이션으로 했던 것처럼
	- 매개변수 자료형은 사용할 dto 받음
		- dto 자료형 바로 앞에 RequestBody 어노테이션 붙여야 json을 직렬화해서 객체에 넣어 줌
	- 반환 타입은 `ResponseEntity<>`
		- 제네릭 타입 안에 Wrapper 클래스 넣어 줌
			- 호출할 service 함수에서 정한 반환 값 자료형(response body에 들어갈 value)과 같은 자료형을 넣어 줘야 함
		- `ResponseEntity.ok(userService.createUserRepository(userDto))`와 같은 메소드는 http 상태값(여기서는 200 OK를 감싼 Enum 값) 반환
			- `private final`로 선언한 service 객체의 메소드 사용
				- 여기서 매개변수로 받은 dto 객체 사용
	- PostMapping 어노테이션 등으로 추가로 뒤에 붙을 엔드포인트 이름 지정
		- `@PostMapping("")`이라고 적으면 RequestedMapping에서 지정한 엔드포인트로 매핑됨
		- 요청의 종류가 달라지면 이름 재사용 가능

### DB에서 pk 값 받아오기
1. repository에서 `find{객체}By{사용할 column 이름}(컬럼);` 함수를 상속받아 선언
	- 반환 타입은 null 값일 수도 있으니 `Optional<{객체}>`
2. service에서 userId(pk)를 받아오는 함수 작성
	- json을 반환해야 하므로 반환 값 자료형은 `Map<String, {pk 자료형}>`
		- key는 무조건 String
	- 매개변수로 DB 탐색에 사용할 값 넣어 줌
		- 이 예제에서는 전화번호 사용(unique)
	- `User` 변수 선언해서 `userRepository.findUserByPhoneNumber(phoneNumber).orElseThrow(() -> new {어딘가에서 선언한 Exception 이름}());`로 탐색한 결과 저장
		- `Optional`을 반환받았으니 `orElseThrow()`로 null일 경우 예외 던져야 함
3. controller에서 Get Mapping으로 해당 값 받아오기
	- 값을 전달받을 때만 동작해야 하므로 response body가 아니라 path variable로 추가
		- `@PathVariable`을 매개변수 자료형 바로 앞에 붙임
			- `http://localhost:8080/user/{phoneNumber}`로 전달 받은 전화번호를 자동으로 매개변수에 전달해 줌
		- 전달받은 request param이 존재하지 않을 경우에는 자동으로 "" 경로에 매핑됨
			- `@GetMapping("/{매개변수 이름}")`을 메소드에 붙임
				- 매개변수 이름과 path variable 이름 다르게 할 수도 있음(추가 설정 필요)
			- `http://localhost:8080/user/(존재하지 않는 전화번호)`일 경우 자동으로 `http://localhost:8080/user` 에 요청 보내게 됨
		- 반환 타입은 `ResponseEntity<?>`
			- `?`는 `Optional`과 같음
			- `return ResponseEntity.ok(userService.getUserId(phoneNumber));`에서 service에서 선언하고 여기서 호출한 `getUserId` 메소드의 반환 값 자료형이 자동으로 들어감(여기서는 service의 메소드에서 지정한  `Map<String, Long>`)
			- 생성자가 아니므로 `<>` 안을 비우면 안됨

### uri vs url
- URI(Uniform Resource Identifier)
	- 통합 자원 식별자
	- 인터넷 상의 Resource(웹 브라우저 파일 및 리소스 포함)를 식별(다른 항목과 구분 위해 Identifier 사용)하는 고유한 문자열 시퀀스
	- ex) naver.com
- URL(Uniform Resource Locator)
	- URI의 일종
	- 네트워크 상에서 통합 자원의 위치를 나타내기 위한 규약
	- 자원 식별자(URI)와 위치를 동시에 보여 줌
	- 웹 사이트 주소 뿐 아니라 프로토콜까지 함께 나타냄(웹에서는 https와 http)
		- ftp, file, ...
	- ex) https://www.naver.com
	- Scheme(리소스 접근에 사용할 프로토콜) + Host(접근할 대상, 즉 서버의 호스트명) + Path(접근할 대상, 즉 서버의 경로에 대한 상세 정보, 이게 URN)
- URN
	- 웹 문서의 물리적 위치와는 상관 없이 웹 문서 자체를 나타냄
	- 개별 자원에 식별자를 부여하는 것
		- 이를 통해 리소스 위치, 프로토콜, 호스트와 관계 없이 위치 파악할 수 있음
			- ex) 웹 문서가 다른 웹 서버로 이동하거나 주소가 바뀌는 등 물리적 위치가 변경되더라도 해당 문서를 찾을 수 있음

### REST API naming convention
- `PROTOCOL//HOST:PORT/{RESTFUL_ENDPOINT}`
- `RESTFUL_ENDPOINT` : `{APPLICATION_CONTEXT}/VERSION/RESOURCE/PARAMETER`
- 동사 대신 명사를 사용
	- operation이 아닌 data(resource) 의미해야 함
	- 동사는 URL에 쓰지 말고 HTTP 메소드로!
		- `GET, POST, PUT, PATCH, DELETE`
	- REST에서 행위(로그인, 결제 등)가 필요한 경우에는 서브 리소스 방식 사용
		- ```java
		  POST /users/login
			POST /orders/{id}/cancel
			POST /payments/{id}/approve
		  ```
- 다수의 resource에 대해서는 복수형 사용
	- singleton resource가 아니라면!
- 단어간 분리에는 `_` 말고 `-` 사용
	- snake case, carmel case 사용 지양
- `/`는 resource 간의 계층 분리에만 사용(URI 맨 뒤에는 붙이지 말기)
- 파일 확장자 굳이 명시하지 말기
- URI에 API 버전 명시
- 리소스에 대해 추가적인 처리(정렬, 필터링, 페이지네이션 등) 필요한 경우 query parameter로 요청 받을 수 있도록 api 작성
	- 추가적인 api 만들어서 해결하지 말기!
### endpoint란
- 서비스를 사용할 수 있도록 서비스에서 제공하는 커뮤니케이션 채널의 한 쪽 끝
- 요청을 받아 응답을 제공하는 서비스를 사용할 수 있는 지점
- API가 서버에서 리소스에 접근할 수 있도록 하는 URL