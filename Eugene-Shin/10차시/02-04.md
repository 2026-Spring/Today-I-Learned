# 10차시(2/4) - record와 pagenation
### record
- private final 안 붙여도 불변 객체로 처리해 줌
- 거의 dto를 위한 데이터 타입
	- 게터나 생성자 어노테이션을 안 붙여도 포함되어 있음(붙이면 안됨)
	- `{레코드 이름}.{멤버변수}`로 접근
		- Jackson은 `{객체 이름}.get{멤버변수이름}()`으로 접근하기 때문에 미들웨어에서 json으로 request 보낼 때 Jackson 그냥 사용하면 안 됨(직접 만든 메소드나 오버라이드해서 써야 함)
	- `public Entity toEntity(Dto)`(request dto에서, static 아님), `public static Dto fromEntity(Entity)`(response dto, AllArgumentConstructor 어노테이션이 기본적으로 포함되어 있으므로 생성자 매개변수 순서 맞춰 `new`로 생성) 등의 메소드 선언해 놓고 사용하면 서비스 단에서 빌더 패턴으로 일일히 객체 생성하지 않아도 됨
		- 예시
			- ```java
			  package com.example.demo.dto.response;

				import com.example.demo.domain.Diary;
				
				import java.time.LocalDate;
				
				public record DiaryResponse(
				        Long id,
				        LocalDate createdAt,
				        String text
				) {
				    public static DiaryResponse fromEntity(Diary diary) {
				        return new DiaryResponse(
				                diary.getId(),
				                diary.getCreatedAt(),
				                diary.getText()
				        );
				    }
				}
			  ```
			  
			  - ```java
			    package com.example.demo.dto.request;

				import com.example.demo.domain.Diary;
				import com.example.demo.domain.User;
				
				import java.time.LocalDate;
				
				public record DiaryRequest(
				        LocalDate createdAt,
				        String text
				) {
				    public Diary toEntity(User user) {
				        return Diary.builder()
				                .user(user)
				                .createdAt(createdAt)
				                .text(text)
				                .build();
				    }
				}

			    ```

### 페이지네이션
- 수많은 데이터를 한 번에 다 뿌려주려면 시간 너무 걸리니 쪼개서 줌
- 총 3개의 클래스(인터페이스 포함) 사용(data jpa에 있음)
	- Page
		- 페이지 요청 조건을 나타내는 인터페이스
		- 사용하는 변수 3개
			- 현재 몇 번째 페이지인가(page_num)
			- 한 화면에 몇 개의 데이터를 줄 것인가(page_size)
			- 정렬 기준(최신순 등)
	- Pageable
		- 인터페이스
	- PageRequest
		- pageable의 구현체
		- 가장 많이 사용
- repository 단에서 list 대신 page 사용
	- Query 어노테이션을 써서 직접 레포지토리 단에 메소드를 만들어 쓰려면 count query(전체 개수 세기)와 query(안의 내용 확인) 총 두 개가 필요
	- cf) jpa repository의 find~By~ 메소드 상속받아 쓰면 count query 불필요(알아서 세 줌)
- Page는 pagenation의 결과를 담는 객체
	- 총 몇 개이고, 더 넘어갈 수 있는지, 그 안의 컨텐츠는 뭔지 등이 들어있음
- 구현
	1. PageResponseDto 만들기(제네릭으로)
		- ```java
		  package com.example.demo.dto.response;

			import org.springframework.data.domain.Page;
			
			import java.util.List;
			
			public record PageDto<T>(
			        List<T> content,
			        Integer pageNum,
			        Integer pageSize,
			        Integer totalPages,
			        Long totalElements,
			        Boolean first,
			        Boolean last
			) {
			    public static <T> PageDto<T> from(Page<?> page, List<T> content) {
			        return new PageDto<>(
			                content,
			                page.getNumber(),
			                page.getSize(),
			                page.getTotalPages(),
			                page.getTotalElements(),
			                page.isFirst(),
			                page.isLast()
			        );
			    }
			}
		  ```
	2. Controller 단에서 Request Param으로 페이지 번호 등 받아올 수 있도록 구현(필수 정보가 아니므로 request param으로 받아오지 않음)
		- default value 속성 지정
		- 지정한 값보다 적을 경우는 반드시 보여줘야 함(마지막 페이지의 요소 개수가 지정 값보다 적을 수 있으므로)
		- ```java
		  @GetMapping("/{userId}/diaries")
		    public ResponseEntity<PageDto<DiaryResponseDto>> getDiaries(
		            @PathVariable Long userId,
		            @RequestParam(defaultValue = "0") Integer pageNum,
		            @RequestParam(defaultValue = "10") Integer pageSize
		    ) {
		        return ResponseEntity.ok(diaryService.getDiaries(userId, pageNum, pageSize));
		    }
		  ```
	3. repository 단에서 메소드 상속받기
		- `public Page<Diary> findByUser(User user, Pageable pageable);`
		- repository 단에서는 가급적 dto가 아니라 domain 객체 반환하게!
	4. service 단의 메소드 작성
		1. PageDto<response 객체> 반환하도록
		2. 페이지 요청 객체 PageRequest 객체 생성
		3. repository 단에서 상속받아 선언한 메소드로 Page 객체 받아서 getContent() 메소드로 diary 리스트 받기
		4. stream 사용해 dto로 변환하여 페이지 객체와 dto 리스트 넘겨주기
		- ```java
		  public PageDto<DiaryResponseDto> getDiaries(Long userId, Integer pageNum, Integer pageSize) {  
		    User user = userRepository.findUserById((userId));  
		    Pageable pageable = PageRequest.of(  
		            pageNum,  
		            pageSize,  
		            Sort.by(Sort.Direction.DESC, "createdAt")   //해당 도메인에 포함된 필드(DB 컬럼명 아니라 변수명)  
		    );  
		  
		    Page<Diary> diaries = diaryRepository.findByUser(user, pageable);  
		  
		    List<DiaryResponseDto> list = diaries.getContent().stream()  
		            .map(DiaryResponseDto::fromEntity)  
		            .toList();  
		  
		    return PageDto.from(diaries, list);  
		}
		  ```
	2. request param 값이 잘못 들어왔을 때는 첫 페이지 보여주도록 service 단에서 예외 처리

### slice
- 앱에서 많이 사용
- 한 번에 몇 개씩 가져올지와 더 내려갈 수 있는지만 확인하면 됨
- 다음 페이지가 있는 지만 알려 주는 페이지네이션이라고 볼 수 있음
- 빠르고 가벼움(무한 스크롤일 경우 이렇게 쓰는 게 나음)