# 7차시(1/26) - Http PUT & FETCH 요청, 일대다 관계
### put vs fetch
- put과 fetch의 용도(절대적인 것 아님, 일종의 규약)
	- put은 받아온 걸 싹 다 바꿈
	- fetch는 받아온 것 중 바뀐 것만 바꿈
- service 단의 update 메소드
	- Transactional 어노테이션이 붙어 있음 -> 영속성 컨텍스트의 관리 대상이 됨
	- 영속성 컨텍스트가 dirty checking 수행
		- repository에서 가져 온 엔티티의 필드 정보(스냅샷)가 바뀌면 반환(트랜잭션 커밋 완료) 시 자동으로 모든 필드 update하는 sql update문을 쏴서 DB에 반영해 줌(entity의 모든 컬럼을 통째로 수정)
		- ```java
			  public boolean updateUser(UpdateDto updateDto) {  
				    User user = userRepository.findUserById(updateDto.getUserId());  
				    user.updateUserInfo(updateDto);  
				  
				    return true;  
				}
		  ```
		- DynamicUpdate 어노테이션을 달아 바뀐 필드만 수정하는 update문을 실행하도록 할 수 있음
			- JPA 스펙이 아닌 하이버네이트 기능
			- domain 단에 붙임
			- 장점
				- 컬럼이 많거나 테이블에 인덱스가 많아서 재정렬이 많이 발생할 때 사용하면 효율적
			- 단점
				- 내부적으로 사용하는 JDBC의 PreparedStatement 클래스가 SQL 구문 캐싱하고 바뀌는 부분만 ?로 표시해 바꿔가면서 쓰도록 구현되어 있는데 변경된 컬럼에 대해서만 쿼리 날리게 되면 캐시의 히트율 떨어짐
				- 객체 변경 여부 정도가 아니라 필드 수준으로 추적해야 하므로 JPA 입장에선 추가 연산 발생
	- dirty checking 등 Hibernate가 자주 쓰이면 느려짐
		- ORM 오버헤드 발생
		- 한 번에 모아서 하는 게 좋음(Hibernate가 전부 수행하게 하지 말고 batch update 등으로 DB에게 맡기기)

### 일대다 관계
- 두 도메인 간 참조 관계 맺어줌
	- 단방향이 아닌 양방향으로(OneToMany, ManyToOne 둘 다 사용)
	- 주인이 되는 쪽에 ManyToOne 어노테이션 사용(pk 받아오는 쪽)
		-  외래키가 필요한 곳(OneToMany)에는 join column을 꼭 같이 사용
			- nullable을 false로 지정해야 함
		- 컬럼 어노테이션 사용하지 않음
		- Eager vs Lazy
			- 기본적으로 Eager(엔티티 조회할 때 hibernate가 자동으로 연관된 모든 엔티티를 SELECT하는 n + 1 문제 발생 가능)
			- diary 하나만 조회했는데 참조하는 user까지 조회하는 예시
				- ![[./스크린샷 2026-01-26 오후 8.50.25]]
			- Lazy -> 필요할 때만 조회함
				- `fetch = FetchType.LAZY` 속성으로 지정 가능
	- fk 제공하는 쪽에 OneToMany 어노테이션 사용
		- List 필드를 사용
			- domain에서 List 필드는 무조건 새 객체(`new ArrayList<>()` 등) 만들어 초기화해야 함
		- mappedBy 속성
			- 양방향 연관관계에서 연관관계의 주인이 아님을 선언하는 속성(FK 수정 권한 없도록 함)
				- 외래키 관리하는 필드가 상대 엔티티에 있다고 선언하는 것
			- 이 속성없으면 JPA가 FK가 어디 있는지 몰라 중간 테이블을 생성함(불필요한 JOIN 테이블)
			- 컬럼명이나 테이블명이 아닌 엔티티명 사용
				- `@OneToMany(mappedBy = "user")`
				- `user`는 `Diary` 클래스 안에 선언된 필드
		- JPA는 DB만 관리할 뿐 양 객체 간의 관계(객체 그래프)는 맞춰 주지 않음
			- service단에서 fk로 참조당하는 쪽의 메소드로 설정해 줘야 함
				- 예시) DiaryService의 createDiary() 함수에서
					- ```java
					  diaryRepository.save(diary);  
						user.addDiary(diary);
					  ```
- onetoone, manytomany는 잘 사용하지 않음
- cf) 엄청 긴 텍스트 받을 때는 Lob 어노테이션 사용

### 계층형 아키텍처
- controller -> service -> repository
- 각 계층은 무조건 하위 계층을 사용해야 함
- 같은 계층을 호출해서는 안됨
- *지키지 않으면 순환 참조 발생*
	- 순환 참조 발생하는 예시(User 엔티티와 Diary 엔티티는 일대다 참조 관계)
	  ```java
		public Map<String, List<Diary>> getDiary(Long userId) {  
		    User user = userRepository.findUserById(userId);  
		  
		    Map<String, List<Diary>> map = new HashMap<>();  
		    map.put("diaries", user.getDiaries());  
		  
		    return map;  
		}
	  ```
		- Spring의 Jackson이 해당 메소드를 controller에서 리턴할 때 자바 객체를 HTTP 응답 Body로 변환하려 함
		- 근데 객체 그래프가 순환하기 때문에 직렬화하려다가 터짐
		- 이러한 이유로 domain 간 순환 참조 막기 위해서 리턴할 때 dto 만들어 대신 사용